{"meta": {"dse_version": "5.0", "aggregates": {"max": "<b>Max</b> - The maximum value recorded during a time interval. A higher maximum value could have occurred without it being recorded.", "average": "<b>Avg</b> - The average of values recorded during a time interval.", "total": "<b>Total</b> - Sum of the values recorded for each node during a time interval.", "min": "<b>Min</b> - The minimal value recorded during a time interval. A lower minimal value could have occurred without it being recorded."}, "include": ["cassandra-metrics-2.1.8.621.json"], "exclude": ["write-latency-op", "read-latency-op", "cf-read-latency-op", "cf-write-latency-op", "active-hinted-handoff", "pending-hinted-handoff", "completed-hinted-handoff", "active-commitlog-archiver", "pending-commitlog-archiver", "completed-commitlog-archiver"], "api_key": "meta"}, "write-ops": {"aggregation_type": "counter", "api_key": "write-ops", "description": "The number of write requests per second on the coordinator nodes, analogous to client writes. Monitoring the number of requests over a given time period reveals system write workload and usage patterns.", "group": "cassandra", "label": "Write Requests", "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Latency", "metric_type": "derive", "path": ["Count"], "priority": 0, "scope": "general", "storage_name": "getSPWriteOperations", "type": "jmx", "unit": "/sec"}, "write-histogram": {"aggregation_type": "histogram", "allow_alerts": true, "api_key": "write-histogram", "description": "The min, median, max, 90th, and 99th percentiles of a client writes. The time period starts when a node receives a client write request, and ends when the node responds back to the client. Depending on consistency level and replication factor, this may include the network latency from writing to the replicas.", "group": "cassandra", "histogram": true, "label": "Write Request Latency (percentiles)", "label_func": "logLabel", "max": "<b>Max</b> - The maximum latency during a time interval.", "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Latency", "invoke": ["values"], "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.", "metric_type": "histogram", "min": "<b>Min</b> - The minimum latency during a time interval.", "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.", "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.", "plot": "Areas", "priority": 0, "scale": "logScale", "scope": "general", "storage_name": "getWriteLatencyHisto", "to_unit": "nsToMs", "from_unit": "msToNs", "type": "jmx", "unit": "ms/op"}, "read-ops": {"aggregation_type": "counter", "api_key": "read-ops", "description": "The number of read requests per second on the coordinator nodes, analogous to client reads. Monitoring the number of requests over a given time period reveals system read workload and usage patterns.", "group": "cassandra", "label": "Read Requests", "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Latency", "metric_type": "derive", "path": ["Count"], "priority": 1, "scope": "general", "storage_name": "getSPReadOperations", "type": "jmx", "unit": "/sec"}, "read-histogram": {"aggregation_type": "histogram", "allow_alerts": true, "api_key": "read-histogram", "description": "The min, median, max, 90th, and 99th percentiles of a client reads. The time period starts when a node receives a client read request, and ends when the node responds back to the client. Depending on consistency level and replication factor, this may include the network latency from requesting the data\u2019s replicas.", "group": "cassandra", "histogram": true, "label": "Read Request Latency (percentiles)", "label_func": "logLabel", "max": "<b>Max</b> - The maximum latency during a time interval.", "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Latency", "invoke": ["values"], "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.", "metric_type": "histogram", "min": "<b>Min</b> - The minimum latency during a time interval.", "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.", "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.", "plot": "Areas", "priority": 1, "scale": "logScale", "scope": "general", "storage_name": "getReadLatencyHisto", "to_unit": "nsToMs", "from_unit": "msToNs", "type": "jmx", "unit": "ms/op"}, "nonheap-committed": {"aggregation_type": "average", "allow_alerts": false, "api_key": "nonheap-committed", "description": "Allocated memory, guaranteed for Java nonheap.", "from_unit": "gbToBytes", "group": "cassandra", "label": "Non Heap Committed", "mbean": "java.lang:type=Memory", "metric_type": "gauge", "path": ["NonHeapMemoryUsage", "committed"], "priority": 10, "scope": "general", "storage_name": "getNonHeapCommitted", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "nonheap-max": {"aggregation_type": "average", "allow_alerts": false, "api_key": "nonheap-max", "description": "Maximum amount that the Java nonheap can grow.", "from_unit": "gbToBytes", "group": "cassandra", "label": "Non Heap Max", "mbean": "java.lang:type=Memory", "metric_type": "gauge", "path": ["NonHeapMemoryUsage", "max"], "priority": 10, "scope": "general", "storage_name": "getNonHeapMax", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "nonheap-used": {"aggregation_type": "average", "allow_alerts": false, "api_key": "nonheap-used", "description": "Average amount of Java nonheap memory used.", "from_unit": "gbToBytes", "group": "cassandra", "label": "Non Heap Used", "mbean": "java.lang:type=Memory", "metric_type": "gauge", "path": ["NonHeapMemoryUsage", "used"], "priority": 10, "scope": "general", "storage_name": "getNonHeapUsed", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "heap-committed": {"aggregation_type": "average", "allow_alerts": false, "api_key": "heap-committed", "description": "Allocated memory guaranteed for the Java heap.", "from_unit": "gbToBytes", "group": "cassandra", "label": "Heap Commited", "mbean": "java.lang:type=Memory", "metric_type": "gauge", "path": ["HeapMemoryUsage", "committed"], "priority": 10, "scope": "general", "storage_name": "getHeapCommitted", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "heap-max": {"aggregation_type": "average", "allow_alerts": true, "api_key": "heap-max", "description": "Maximum amount that the Java heap can grow.", "from_unit": "gbToBytes", "group": "cassandra", "label": "Heap Max", "mbean": "java.lang:type=Memory", "metric_type": "gauge", "minstep": 0.001, "path": ["HeapMemoryUsage", "max"], "priority": 10, "scope": "general", "storage_name": "getHeapMax", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "heap-used": {"aggregation_type": "average", "allow_alerts": true, "api_key": "heap-used", "description": "Average amount of Java heap memory used.", "from_unit": "gbToBytes", "group": "cassandra", "label": "Heap Used", "mbean": "java.lang:type=Memory", "metric_type": "gauge", "minstep": 0.001, "path": ["HeapMemoryUsage", "used"], "priority": 10, "scope": "general", "storage_name": "getHeapUsed", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cms-collection-count": {"aggregation_type": "counter", "allow_alerts": true, "api_key": "cms-collection-count", "description": "Number of concurrent mark sweep garbage collections performed per second.", "group": "cassandra", "label": "JVM CMS Collection Count", "mbean": "java.lang:type=GarbageCollector,name=ConcurrentMarkSweep", "metric_type": "derive", "minstep": 0.01, "path": ["CollectionCount"], "priority": 15, "scope": "general", "storage_name": "getCMSCollectionCount", "type": "jmx", "unit": "/sec"}, "par-new-collection-count": {"aggregation_type": "counter", "allow_alerts": true, "api_key": "par-new-collection-count", "description": "Number of ParNew garbage collections performed per second. ParNew collections pause all work in the JVM but should finish quickly.", "group": "cassandra", "label": "JVM ParNew Collection Count", "mbean": "java.lang:type=GarbageCollector,name=ParNew", "metric_type": "derive", "minstep": 0.1, "path": ["CollectionCount"], "priority": 15, "scope": "general", "storage_name": "getParNewCollectionCount", "type": "jmx", "unit": "/sec"}, "cms-collection-time": {"aggregation_type": "counter", "allow_alerts": true, "api_key": "cms-collection-time", "description": "Average number of milliseconds spent performing CMS garbage collections per second.", "group": "cassandra", "hardmax": 1000, "label": "JVM CMS Collection Time", "mbean": "java.lang:type=GarbageCollector,name=ConcurrentMarkSweep", "metric_type": "derive", "path": ["CollectionTime"], "priority": 15, "scope": "general", "selectable": true, "storage_name": "getCMSCollectionTime", "type": "jmx", "unit": "ms/sec"}, "par-new-collection-time": {"aggregation_type": "counter", "allow_alerts": true, "api_key": "par-new-collection-time", "description": "Average number of milliseconds spent performing ParNew garbage collections per second. ParNew collections pause all work in the JVM but should finish quickly.", "group": "cassandra", "hardmax": 1000, "label": "JVM ParNew Collection Time", "mbean": "java.lang:type=GarbageCollector,name=ParNew", "metric_type": "derive", "path": ["CollectionTime"], "priority": 15, "scope": "general", "selectable": true, "storage_name": "getParNewCollectionTime", "type": "jmx", "unit": "ms/sec"}, "g1-old-collection-count": {"aggregation_type": "counter", "allow_alerts": true, "api_key": "g1-old-collection-count", "description": "Number of G1 old generation garbage collections performed per second.", "group": "cassandra", "label": "JVM G1 Old Collection Count", "mbean": "java.lang:type=GarbageCollector,name=G1 Old Generation", "metric_type": "derive", "path": ["CollectionCount"], "minstep": 0.01, "priority": 15, "scope": "general", "selectable": true, "type": "jmx", "unit": "/sec"}, "g1-old-collection-time": {"aggregation_type": "counter", "allow_alerts": true, "api_key": "g1-old-collection-time", "description": "Average number of milliseconds spent performing G1 old generation garbage collections per second.", "group": "cassandra", "hardmax": 1000, "label": "JVM G1 Old Collection Time", "mbean": "java.lang:type=GarbageCollector,name=G1 Old Generation", "metric_type": "derive", "path": ["CollectionTime"], "priority": 15, "scope": "general", "selectable": true, "type": "jmx", "unit": "ms/sec"}, "g1-young-collection-count": {"aggregation_type": "counter", "allow_alerts": true, "api_key": "g1-young-collection-count", "description": "Number of G1 young generation garbage collections performed per second.", "group": "cassandra", "label": "JVM G1 Young Collection Count", "mbean": "java.lang:type=GarbageCollector,name=G1 Young Generation", "metric_type": "derive", "path": ["CollectionCount"], "minstep": 0.01, "priority": 15, "scope": "general", "selectable": true, "type": "jmx", "unit": "/sec"}, "g1-young-collection-time": {"aggregation_type": "counter", "allow_alerts": true, "api_key": "g1-young-collection-time", "description": "Average number of milliseconds spent performing G1 young generation garbage collections per second.", "group": "cassandra", "hardmax": 1000, "label": "JVM G1 Young Collection Time", "mbean": "java.lang:type=GarbageCollector,name=G1 Young Generation", "metric_type": "derive", "path": ["CollectionTime"], "priority": 15, "scope": "general", "selectable": true, "type": "jmx", "unit": "ms/sec"}, "data-load": {"aggregation_type": "counter", "api_key": "data-load", "description": "The live disk space used by all tables on a node.", "from_unit": "gbToBytes", "group": "cassandra", "label": "Data Size", "mbean": "org.apache.cassandra.metrics:type=Storage,name=Load", "metric_type": "gauge", "path": ["Count"], "priority": 20, "scope": "general", "storage_name": "getDataLoad", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "total-bytes-compacted": {"aggregation_type": "counter", "api_key": "total-bytes-compacted", "description": "Number of bytes compacted per second.", "from_unit": "gbToBytes", "group": "cassandra", "label": "Total Bytes Compacted", "mbean": "org.apache.cassandra.metrics:type=Compaction,name=BytesCompacted", "metric_type": "derive", "path": ["Count"], "priority": 20, "scope": "general", "storage_name": "getTotalBytesCompacted", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize", "unit": "/sec"}, "total-compactions-completed": {"aggregation_type": "counter", "api_key": "total-compactions-completed", "description": "Number of compaction tasks completed per second.", "group": "cassandra", "label": "Total Compactions", "mbean": "org.apache.cassandra.metrics:type=Compaction,name=CompletedTasks", "metric_type": "derive", "minstep": 0.01, "path": ["Value"], "priority": 20, "scope": "general", "storage_name": "getTotalCompactionsCompleted", "type": "jmx", "unit": "/sec"}, "pending-compaction-tasks": {"aggregation_type": "counter", "api_key": "pending-compaction-tasks", "description": "Estimated number of compactions required to achieve the desired state. This includes the pending queue to the compaction executor and additional tasks that may be created from their completion.", "group": "cassandra", "label": "Compactions Pending", "mbean": "org.apache.cassandra.metrics:type=Compaction,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 20, "scope": "general", "storage_name": "getCMPendingTasks", "type": "jmx"}, "all-pending": {"api_key": "all-pending", "description": "Aggregate of thread pools pending queues that can be used to identify where things are backing up internally. This doesn't include pending compactions because it includes an estimate outside of the task queue or the hinted hand off queue, which can be in constant state of being on.", "group": "cassandra", "label": "Task Queues", "metrics": ["pending-anti-entropy-stage", "pending-cache-cleanup-stage", "pending-compaction-executor", "pending-counter-mutations", "pending-flushes", "pending-gossip-stage", "pending-hint-dispatcher", "pending-internal-response-stage", "pending-memtable-post-flush", "pending-migration-stage", "pending-misc-stage", "pending-mutation-stage", "pending-native-transport-requests", "pending-pending-range-calculator", "pending-read-repair-stage", "pending-read-stage", "pending-request-response-stage", "pending-secondary-index-management", "pending-validation-executor", "pending-view-mutation-stage"], "plot": "StackedAreas", "priority": 25, "unit": "tasks"}, "all-dropped": {"api_key": "all-dropped", "description": "Aggregate of different messages that might be thrown away.", "group": "cassandra", "label": "TP: Dropped Tasks", "metrics": ["dropped-counter-mutations", "dropped-mutations", "dropped-read-repairs", "dropped-reads", "dropped-ranged-slice-reads", "dropped-paged-range-reads", "dropped-request-responses"], "plot": "StackedAreas", "priority": 28, "unit": "tasks"}, "dropped-counter-mutations": {"aggregation_type": "counter", "api_key": "dropped-counter-mutations", "description": "Mutation was seen after the timeout (write_request_timeout_in_ms) so was thrown away. This client might have timed out before it met the required consistency level, but might have succeeded as well. Hinted handoffs and read repairs should resolve inconsistencies but a repair can ensure it.", "group": "cassandra", "label": "TP: Dropped Counter Mutations", "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=COUNTER_MUTATION,name=Dropped", "metric_type": "derive", "path": ["Count"], "priority": 29, "scope": "general", "type": "jmx"}, "dropped-mutations": {"aggregation_type": "counter", "api_key": "dropped-mutations", "description": "Mutation was seen after the timeout (write_request_timeout_in_ms) so was thrown away. This client might have timed out before it met the required consistency level, but might have succeeded as well. Hinted handoffs and read repairs should resolve inconsistencies but a repair can ensure it.", "group": "cassandra", "label": "TP: Dropped Mutations", "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=MUTATION,name=Dropped", "metric_type": "derive", "path": ["Count"], "priority": 29, "scope": "general", "type": "jmx"}, "dropped-reads": {"aggregation_type": "counter", "api_key": "dropped-reads", "description": "A local read request was received after the timeout (read_request_timeout_in_ms) so it was thrown away because it would have already either been completed and sent to client or sent back as a timeout error.", "group": "cassandra", "label": "TP: Dropped Reads", "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=READ,name=Dropped", "metric_type": "derive", "path": ["Count"], "priority": 29, "scope": "general", "type": "jmx"}, "dropped-ranged-slice-reads": {"aggregation_type": "counter", "api_key": "dropped-ranged-slice-reads", "description": "A local ranged read request was received after the timeout (range_request_timeout_in_ms) so it was thrown away because it would have already either been completed and sent to client or sent back as a timeout error.", "group": "cassandra", "label": "TP: Dropped Ranged Slice Reads", "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=RANGE_SLICE,name=Dropped", "metric_type": "derive", "path": ["Count"], "priority": 29, "scope": "general", "type": "jmx"}, "dropped-paged-range-reads": {"aggregation_type": "counter", "api_key": "dropped-paged-range-reads", "description": "A local paged read request was received after the timeout (request_timeout_in_ms) so it was thrown away because it would have already either been completed and sent to client or sent back as a timeout error.", "group": "cassandra", "label": "TP: Dropped Paged Range Reads", "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=PAGED_RANGE,name=Dropped", "metric_type": "derive", "min-version": "2.0.0", "path": ["Count"], "priority": 29, "scope": "general", "type": "jmx"}, "dropped-request-responses": {"aggregation_type": "counter", "api_key": "dropped-request-responses", "description": "A response to a request was received after the timeout (request_timeout_in_ms) so it was thrown away because it would have already either been completed and sent to client or sent back as a timeout error.", "group": "cassandra", "label": "TP: Dropped Request Responses", "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=REQUEST_RESPONSE,name=Dropped", "metric_type": "derive", "path": ["Count"], "priority": 29, "scope": "general", "type": "jmx"}, "dropped-read-repairs": {"aggregation_type": "counter", "api_key": "dropped-read-repairs", "description": "The Mutation was seen after the timeout (write_request_timeout_in_ms) so was thrown away. With the read repair timeout, the node still exists in an inconsistent state.", "group": "cassandra", "label": "TP: Dropped Read Repairs", "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=READ_REPAIR,name=Dropped", "metric_type": "derive", "path": ["Count"], "priority": 29, "scope": "general", "type": "jmx"}, "pending-flushes": {"aggregation_type": "counter", "api_key": "pending-flushes", "description": "Number of memtables queued for the flush process. A flush sorts and writes the memtables to disk.", "group": "cassandra", "label": "TP: Flushes Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtableFlushWriter,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "pending-gossip-stage": {"aggregation_type": "counter", "api_key": "pending-gossip-stage", "description": "Number of gossip messages and acknowledgments queued and waiting to be sent or received.", "group": "cassandra", "label": "TP: Gossip Tasks Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=GossipStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getGossipStagePending", "type": "jmx"}, "pending-internal-response-stage": {"aggregation_type": "counter", "api_key": "pending-internal-response-stage", "description": "Number of pending tasks from internal tasks, such as nodes joining and leaving the cluster.", "group": "cassandra", "label": "TP: Internal Responses Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=InternalResponseStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getInternRespStagePending", "type": "jmx"}, "pending-anti-entropy-stage": {"aggregation_type": "counter", "api_key": "pending-anti-entropy-stage", "description": "Repair tasks pending, such as handling the merkle tree transfer after the validation compaction.", "group": "cassandra", "label": "TP: Manual Repair Tasks Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=AntiEntropyStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getAesPendingTasks", "type": "jmx"}, "pending-cache-cleanup-stage": {"aggregation_type": "counter", "api_key": "pending-cache-cleanup-stage", "description": "Tasks pending to clean row caches during a cleanup compaction.", "group": "cassandra", "label": "TP: Cache Cleaning Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CacheCleanupExecutor,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "pending-memtable-post-flush": {"aggregation_type": "counter", "api_key": "pending-memtable-post-flush", "description": "Tasks related to the last step in flushing memtables to disk as SSTables. Includes removing unnecessary commitlog files and committing Solr-based secondary indexes.", "group": "cassandra", "label": "TP: Post Flushes Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtablePostFlush,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "pending-migration-stage": {"aggregation_type": "counter", "api_key": "pending-migration-stage", "description": "Number of pending tasks from system methods that modified the schema.", "group": "cassandra", "label": "TP: Migrations Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MigrationStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getMigrationStagePending", "type": "jmx"}, "pending-misc-stage": {"aggregation_type": "counter", "api_key": "pending-misc-stage", "description": "Number of pending tasks from infrequently run operations, such as taking a snapshot or processing the notification of a completed replication.", "group": "cassandra", "label": "TP: Misc. Tasks Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MiscStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getMiscStagePending", "type": "jmx"}, "pending-read-stage": {"aggregation_type": "counter", "api_key": "pending-read-stage", "description": "Number of pending read requests. Read requests read data off of disk and deserialize cached data.", "group": "cassandra", "label": "TP: Read Requests Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getReadStagePending", "type": "jmx"}, "pending-read-repair-stage": {"aggregation_type": "counter", "api_key": "pending-read-repair-stage", "description": "Number of read repair operations in the queue waiting to run.", "group": "cassandra", "label": "TP: Read Repair Tasks Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadRepairStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getReadRepairStagePending", "type": "jmx"}, "pending-request-response-stage": {"aggregation_type": "counter", "api_key": "pending-request-response-stage", "description": "Number of pending callbacks to execute after a task on a remote node completes.", "group": "cassandra", "label": "TP: Request Responses Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=RequestResponseStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getRequestResponseStagePending", "type": "jmx"}, "pending-mutation-stage": {"aggregation_type": "counter", "api_key": "pending-mutation-stage", "description": "Number of write requests received by the cluster and waiting to be handled.", "group": "cassandra", "label": "TP: Write Requests Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=MutationStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getMutationStagePending", "type": "jmx"}, "pending-validation-executor": {"aggregation_type": "counter", "api_key": "pending-validation-executor", "description": "Pending task to read data from sstables and generate a merkle tree for a repair.", "group": "cassandra", "label": "TP: Validation Executor Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=ValidationExecutor,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getValidationExecutorPending", "type": "jmx"}, "pending-compaction-executor": {"aggregation_type": "counter", "api_key": "pending-compaction-executor", "description": "Pending compactions that are known. This may deviate from \"pending compactions\" which includes an estimate of tasks that these pending tasks may create after completion.", "group": "cassandra", "label": "TP: Compaction Executor Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CompactionExecutor,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getCompactionExecutorPending", "type": "jmx"}, "pending-pending-range-calculator": {"aggregation_type": "counter", "api_key": "pending-pending-range-calculator", "description": "Pending tasks to calculate the ranges according to bootsrapping and leaving nodes.", "group": "cassandra", "label": "TP: Pending Range Calculator Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=PendingRangeCalculator,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getPendingRangeCalculatorPending", "type": "jmx"}, "pending-native-transport-requests": {"aggregation_type": "counter", "api_key": "pending-native-transport-requests", "description": "Native Transport Requests Requests Pending", "group": "cassandra", "label": "TP: Native Transport Requests Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getNativeTransportRequestsPending", "type": "jmx"}, "active-flushes": {"aggregation_type": "counter", "api_key": "active-flushes", "description": "Up to memtable_flush_writers concurrent tasks to flush and write the memtables to disk.", "group": "cassandra", "label": "TP: Flushes Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtableFlushWriter,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "active-gossip-stage": {"aggregation_type": "counter", "api_key": "active-gossip-stage", "description": "Number of gossip messages and acknowledgments actively being sent or received.", "group": "cassandra", "label": "TP: Gossip Tasks Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=GossipStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getGossipStageActive", "type": "jmx"}, "active-internal-response-stage": {"aggregation_type": "counter", "api_key": "active-internal-response-stage", "description": "Number of active tasks from internal tasks, such as nodes joining and leaving the cluster.", "group": "cassandra", "label": "TP: Internal Responses Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=InternalResponseStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getInternRespStageActive", "type": "jmx"}, "active-anti-entropy-stage": {"aggregation_type": "counter", "api_key": "active-anti-entropy-stage", "description": "Repair tasks active, such as handling the merkle tree transfer after the validation compaction.", "group": "cassandra", "label": "TP: Manual Repair Tasks Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=AntiEntropyStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getAesActiveTasks", "type": "jmx"}, "active-cache-cleanup-stage": {"aggregation_type": "counter", "api_key": "active-cache-cleanup-stage", "description": "Tasks to clean row caches during a cleanup compaction.", "group": "cassandra", "label": "TP: Cache Cleaning Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CacheCleanupExecutor,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "active-memtable-post-flush": {"aggregation_type": "counter", "api_key": "active-memtable-post-flush", "description": "Tasks related to the last step in flushing memtables to disk as SSTables. Includes removing unnecessary commitlog files and committing Solr-based secondary indexes.", "group": "cassandra", "label": "TP: Post Flushes Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtablePostFlush,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "active-migration-stage": {"aggregation_type": "counter", "api_key": "active-migration-stage", "description": "Number of active tasks from system methods that modified the schema.", "group": "cassandra", "label": "TP: Migrations Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MigrationStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getMigrationStageActive", "type": "jmx"}, "active-misc-stage": {"aggregation_type": "counter", "api_key": "active-misc-stage", "description": "Number of active tasks from infrequently run operations, such as taking a snapshot or processing the notification of a completed replication.", "group": "cassandra", "label": "TP: Misc. Tasks Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MiscStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getMiscStageActive", "type": "jmx"}, "active-read-stage": {"aggregation_type": "counter", "api_key": "active-read-stage", "description": "Number of active read requests. Read requests read data off of disk and deserialize cached data.", "group": "cassandra", "label": "TP: Read Requests Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getReadStageActive", "type": "jmx"}, "active-read-repair-stage": {"aggregation_type": "counter", "api_key": "active-read-repair-stage", "description": "Number of read repair operations actively being run.", "group": "cassandra", "label": "TP: Read Repair Tasks Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadRepairStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getReadRepairStageActive", "type": "jmx"}, "active-request-response-stage": {"aggregation_type": "counter", "api_key": "active-request-response-stage", "description": "Number of callbacks to being executed after a task on a remote node is completed.", "group": "cassandra", "label": "TP: Request Responses Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=RequestResponseStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getRequestResponseStageActive", "type": "jmx"}, "active-mutation-stage": {"aggregation_type": "counter", "api_key": "active-mutation-stage", "description": "Number of write requests being handled.", "group": "cassandra", "label": "TP: Write Requests Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=MutationStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "active-validation-executor": {"aggregation_type": "counter", "api_key": "active-validation-executor", "description": "Active task to read data from sstables and generate a merkle tree for a repair.", "group": "cassandra", "label": "TP: Validation Executor Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=ValidationExecutor,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getValidationExecutorActive", "type": "jmx"}, "active-compaction-executor": {"aggregation_type": "counter", "api_key": "active-compaction-executor", "description": "Active compactions that are known.", "group": "cassandra", "label": "TP: Compaction Executor Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CompactionExecutor,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getCompactionExecutorActive", "type": "jmx"}, "active-pending-range-calculator": {"aggregation_type": "counter", "api_key": "active-pending-range-calculator", "description": "Active tasks to calculate the ranges according to bootsrapping and leaving nodes.", "group": "cassandra", "label": "TP: Pending Range Calculator Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=PendingRangeCalculator,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getPendingRangeCalculatorActive", "type": "jmx"}, "active-native-transport-requests": {"aggregation_type": "counter", "api_key": "active-native-transport-requests", "description": "Native Transport Requests Requests Active", "group": "cassandra", "label": "TP: Native Transport Requests Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getNativeTransportRequestsActive", "type": "jmx"}, "completed-flushes": {"aggregation_type": "counter", "api_key": "completed-flushes", "description": "Number of memtables flushed to disk since the nodes start.", "group": "cassandra", "label": "TP: Flushes Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtableFlushWriter,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "completed-gossip-stage": {"aggregation_type": "counter", "api_key": "completed-gossip-stage", "description": "Number of gossip messages and acknowledgments recently sent or received.", "group": "cassandra", "label": "TP: Gossip Tasks Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=GossipStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getGossipStageCompleted", "type": "jmx"}, "completed-internal-response-stage": {"aggregation_type": "counter", "api_key": "completed-internal-response-stage", "description": "Number of recently completed tasks from internal tasks, such as nodes joining and leaving the cluster.", "group": "cassandra", "label": "TP: Internal Responses Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=InternalResponseStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getInternRespStageCompleted", "type": "jmx"}, "completed-anti-entropy-stage": {"aggregation_type": "counter", "api_key": "completed-anti-entropy-stage", "description": "Repair tasks recently completed, such as handling the merkle tree transfer after the validation compaction.", "group": "cassandra", "label": "TP: Manual Repair Tasks Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=AntiEntropyStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getAesCompletedTasks", "type": "jmx"}, "completed-cache-cleanup-stage": {"aggregation_type": "counter", "api_key": "completed-cache-cleanup-stage", "description": "Tasks to clean row caches during a cleanup compaction.", "group": "cassandra", "label": "TP: Cache Cleaning Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CacheCleanupExecutor,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "completed-memtable-post-flush": {"aggregation_type": "counter", "api_key": "completed-memtable-post-flush", "description": "Tasks related to the last step in flushing memtables to disk as SSTables. Includes removing unnecessary commitlog files and committing Solr-based secondary indexes.", "group": "cassandra", "label": "TP: Post Flushes Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtablePostFlush,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "completed-migration-stage": {"aggregation_type": "counter", "api_key": "completed-migration-stage", "description": "Number of completed tasks from system methods that modified the schema.", "group": "cassandra", "label": "TP: Migrations Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MigrationStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getMigrationStageCompleted", "type": "jmx"}, "completed-misc-stage": {"aggregation_type": "counter", "api_key": "completed-misc-stage", "description": "Number of completed tasks from infrequently run operations, such as taking a snapshot or processing the notification of a completed replication.", "group": "cassandra", "label": "TP: Misc. Tasks Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MiscStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getMiscStageCompleted", "type": "jmx"}, "completed-read-stage": {"aggregation_type": "counter", "api_key": "completed-read-stage", "description": "Number of completed read requests. Read requests read data off of disk and deserialize cached data.", "group": "cassandra", "label": "TP: Read Requests Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getReadStageCompleted", "type": "jmx"}, "completed-read-repair-stage": {"aggregation_type": "counter", "api_key": "completed-read-repair-stage", "description": "Number of read repair operations recently completed.", "group": "cassandra", "label": "TP: Read Repair Tasks Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadRepairStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getReadRepairStageCompleted", "type": "jmx"}, "completed-request-response-stage": {"aggregation_type": "counter", "api_key": "completed-request-response-stage", "description": "Number of completed callbacks executed after a task on a remote node is completed.", "group": "cassandra", "label": "TP: Request Responses Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=RequestResponseStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getRequestResponseStageCompleted", "type": "jmx"}, "completed-mutation-stage": {"aggregation_type": "counter", "api_key": "completed-mutation-stage", "description": "Number of write requests received by the cluster that have been handled.", "group": "cassandra", "label": "TP: Write Requests Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=MutationStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getMutationStageCompleted", "type": "jmx"}, "completed-validation-executor": {"aggregation_type": "counter", "api_key": "completed-validation-executor", "description": "Completed tasks to read data from sstables and generate a merkle tree for a repair.", "group": "cassandra", "label": "TP: Validation Executor Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=ValidationExecutor,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getValidationExecutorCompleted", "type": "jmx"}, "completed-compaction-executor": {"aggregation_type": "counter", "api_key": "completed-compaction-executor", "description": "Completed compactions.", "group": "cassandra", "label": "TP: Compaction Executor Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CompactionExecutor,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getCompactionExecutorCompleted", "type": "jmx"}, "completed-pending-range-calculator": {"aggregation_type": "counter", "api_key": "completed-pending-range-calculator", "description": "Completed tasks to calculate the ranges according to bootsrapping and leaving nodes.", "group": "cassandra", "label": "TP: Pending Range Calculator Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=PendingRangeCalculator,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getPendingRangeCalculatorCompleted", "type": "jmx"}, "completed-native-transport-requests": {"aggregation_type": "counter", "api_key": "completed-native-transport-requests", "description": "Native Transport Requests Requests Completed", "group": "cassandra", "label": "TP: Native Transport Requests Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "storage_name": "getNativeTransportRequestsCompleted", "type": "jmx"}, "blocked-native-transport-requests": {"aggregation_type": "counter", "api_key": "blocked-native-transport-requests", "description": "Native Transport Requests Requests Blocked", "group": "cassandra", "label": "TP: Native Transport Requests Blocked", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=CurrentlyBlockedTasks", "metric_type": "gauge", "path": ["Count"], "priority": 30, "scope": "general", "storage_name": "getNativeTransportRequestsBlocked", "type": "jmx"}, "total-blocked-native-transport-requests": {"aggregation_type": "counter", "api_key": "total-blocked-native-transport-requests", "description": "Total Native Transport Requests Requests Blocked", "group": "cassandra", "label": "TP: Total Native Transport Requests Blocked", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=TotalBlockedTasks", "metric_type": "gauge", "path": ["Count"], "priority": 30, "scope": "general", "storage_name": "getNativeTransportRequestsTotalBlocked", "type": "jmx"}, "key-cache-hits": {"aggregation_type": "average", "api_key": "key-cache-hits", "description": "The number of key cache hits per second. This will avoid possible disk seeks when finding a partition in an SSTable.", "group": "cassandra", "label": "KeyCache Hits", "mbean": "org.apache.cassandra.metrics:type=Cache,scope=KeyCache,name=Hits", "metric_type": "derive", "path": ["Count"], "priority": 35, "scope": "general", "storage_name": "getKeyCacheHits", "type": "jmx", "unit": "/sec"}, "key-cache-requests": {"aggregation_type": "average", "api_key": "key-cache-requests", "description": "The number of key cache requests per second.", "group": "cassandra", "label": "KeyCache Requests", "mbean": "org.apache.cassandra.metrics:type=Cache,scope=KeyCache,name=Requests", "metric_type": "derive", "path": ["Count"], "priority": 35, "scope": "general", "storage_name": "getKeyCacheRequests", "type": "jmx", "unit": "/sec"}, "key-cache-hit-rate": {"aggregation_type": "average", "api_key": "key-cache-hit-rate", "description": "The percentage of key cache lookups that resulted in a hit.", "from_unit": "fromPercentage", "group": "cassandra", "label": "KeyCache Hit Rate", "mbean": "org.apache.cassandra.metrics:type=Cache,scope=KeyCache,name=OneMinuteHitRate", "metric_type": "gauge", "path": ["Value"], "priority": 35, "scope": "general", "storage_name": "getKeyCacheRecentHitRate", "to_unit": "toPercentage", "type": "jmx", "render_type": "percentage"}, "row-cache-hits": {"aggregation_type": "average", "api_key": "row-cache-hits", "description": "The number of row cache hits per second.", "group": "cassandra", "label": "RowCache Hits", "mbean": "org.apache.cassandra.metrics:type=Cache,scope=RowCache,name=Hits", "metric_type": "derive", "path": ["Count"], "priority": 35, "scope": "general", "storage_name": "getRowCacheHits", "type": "jmx", "unit": "/sec"}, "row-cache-requests": {"aggregation_type": "average", "api_key": "row-cache-requests", "description": "The number of row cache requests per second.", "group": "cassandra", "label": "RowCache Requests", "mbean": "org.apache.cassandra.metrics:type=Cache,scope=RowCache,name=Requests", "metric_type": "derive", "path": ["Count"], "priority": 35, "scope": "general", "storage_name": "getRowCacheRequests", "type": "jmx", "unit": "/sec"}, "row-cache-hit-rate": {"aggregation_type": "average", "api_key": "row-cache-hit-rate", "description": "The percentage of row cache lookups that resulted in a hit.", "from_unit": "fromPercentage", "group": "cassandra", "label": "RowCache Hit Rate", "mbean": "org.apache.cassandra.metrics:type=Cache,scope=RowCache,name=OneMinuteHitRate", "metric_type": "gauge", "path": ["Value"], "priority": 35, "scope": "general", "storage_name": "getRowCacheRecentHitRate", "to_unit": "toPercentage", "type": "jmx", "render_type": "percentage"}, "native-connections": {"aggregation_type": "counter", "api_key": "native-connections", "description": "The number of clients connected using the native protocol.", "group": "cassandra", "label": "Native Clients", "mbean": "org.apache.cassandra.metrics:type=Client,name=connectedNativeClients", "metric_type": "gauge", "min-version": "1.2.11", "path": ["Value"], "priority": 40, "scope": "general", "storage_name": "getNativeClientCount", "type": "jmx"}, "thrift-connections": {"aggregation_type": "counter", "api_key": "thrift-connections", "description": "The number of clients connected via thrift.", "group": "cassandra", "label": "Thrift Clients", "mbean": "org.apache.cassandra.metrics:type=Client,name=connectedThriftClients", "metric_type": "gauge", "min-version": "1.2.11", "path": ["Value"], "priority": 40, "scope": "general", "storage_name": "getThriftClientCount", "type": "jmx"}, "read-repair-attempted": {"aggregation_type": "counter", "api_key": "read-repair-attempted", "description": "Number of read requests where the number of nodes queried possibly exceeds the consistency level requested in order to check for a possible digest mismatch.", "group": "cassandra", "label": "Read Repairs Attempted", "mbean": "org.apache.cassandra.metrics:type=ReadRepair,name=Attempted", "metric_type": "derive", "path": ["Count"], "priority": 45, "scope": "general", "storage_name": "getReadRepairAttempted", "type": "jmx", "unit": "/sec"}, "read-repaired-background": {"aggregation_type": "counter", "api_key": "read-repaired-background", "description": "Corresponds to a digest mismatch that occurred after a completed read, outside of the client read loop.", "group": "cassandra", "label": "Asynchronous Read Repairs", "mbean": "org.apache.cassandra.metrics:type=ReadRepair,name=RepairedBackground", "metric_type": "derive", "path": ["Count"], "priority": 45, "scope": "general", "storage_name": "getReadRepairedBackground", "type": "jmx", "unit": "/sec"}, "read-repaired-blocking": {"aggregation_type": "counter", "api_key": "read-repaired-blocking", "description": "Corresponds to the number of times there was a digest mismatch within the requested consistency level and a full data read was started.", "group": "cassandra", "label": "Synchronous Read Repairs", "mbean": "org.apache.cassandra.metrics:type=ReadRepair,name=RepairedBlocking", "metric_type": "derive", "path": ["Count"], "priority": 45, "scope": "general", "storage_name": "getReadRepairedBlocking", "type": "jmx", "unit": "/sec"}, "cf-write-ops": {"aggregation_type": "counter", "alerts_label": "Local Writes", "api_key": "cf-write-ops", "is_table_metric": true, "description": "Local write requests per second. Local writes update the table's memtable and appends to a commitlog.", "group": "cf", "label": "TBL: Local Writes", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=WriteLatency", "metric_type": "derive", "path": ["Count"], "scope": "cf", "storage_name": "getWriteCount", "type": "jmx", "unit": "/sec"}, "cf-local-write-latency": {"aggregation_type": "histogram", "allow_alerts": true, "api_key": "cf-local-write-latency", "is_table_metric": true, "description": "The min, median, max, 90th, and 99th percentile of the response times to write data to a table's memtable. The elapsed time from when the replica receives the request from a coordinator and returns a response.", "group": "cf", "histogram": true, "label": "TBL: Local Write Latency (percentiles)", "label_func": "logLabel", "max": "<b>Max</b> - The maximum latency during a time interval.", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=WriteLatency", "invoke": ["values"], "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.", "metric_type": "histogram", "min": "<b>Min</b> - The minimum latency during a time interval.", "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.", "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.", "plot": "Areas", "scale": "logScale", "scope": "cf", "storage_name": "getCFLocalWriteLatency", "to_unit": "nsToMs", "from_unit": "msToNs", "type": "jmx", "unit": "ms/op"}, "cf-read-ops": {"aggregation_type": "counter", "alerts_label": "Local Reads", "api_key": "cf-read-ops", "is_table_metric": true, "description": "Local read requests per second. Local reads retrieve data from a table's memtable and any necessary SSTables on disk.", "group": "cf", "label": "TBL: Local Reads", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=ReadLatency", "metric_type": "derive", "path": ["Count"], "scope": "cf", "storage_name": "getReadCount", "type": "jmx", "unit": "/sec"}, "cf-local-read-latency": {"aggregation_type": "histogram", "allow_alerts": true, "api_key": "cf-local-read-latency", "is_table_metric": true, "description": "The min, median, max, 90th, and 99th percentile of the response time to read data from the memtable and sstables for a specific table. The elapsed time from when the replica receives the request from a coordinator and returns a response.", "group": "cf", "histogram": true, "label": "TBL: Local Read Latency (percentiles)", "label_func": "logLabel", "max": "<b>Max</b> - The maximum latency during a time interval.", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=ReadLatency", "invoke": ["values"], "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.", "metric_type": "histogram", "min": "<b>Min</b> - The minimum latency during a time interval.", "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.", "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.", "plot": "Areas", "scale": "logScale", "scope": "cf", "storage_name": "getCFLocalReadLatency", "to_unit": "nsToMs", "from_unit": "msToNs", "type": "jmx", "unit": "ms/op"}, "cf-live-disk-used": {"aggregation_type": "counter", "alerts_label": "Live Disk Used", "api_key": "cf-live-disk-used", "is_table_metric": true, "description": "Disk space used by live SSTables. There might be obsolete SSTables not included.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Live Disk Used", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=LiveDiskSpaceUsed", "metric_type": "gauge", "path": ["Count"], "postprocess": ["neg-to-nil"], "scope": "cf", "storage_name": "getLiveDiskSpaceUsed", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-total-disk-used": {"aggregation_type": "counter", "alerts_label": "Total Disk Used", "api_key": "cf-total-disk-used", "is_table_metric": true, "description": "Disk space used by a table by SSTables, including obsolete ones waiting to be garbage collected.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Total Disk Used", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=TotalDiskSpaceUsed", "metric_type": "gauge", "path": ["Count"], "postprocess": ["neg-to-nil"], "scope": "cf", "storage_name": "getTotalDiskSpaceUsed", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-live-sstables": {"aggregation_type": "counter", "alerts_label": "SSTable Count", "api_key": "cf-live-sstables", "is_table_metric": true, "description": "Total number of SSTables for a table.", "group": "cf", "label": "TBL: SSTable Count", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=LiveSSTableCount", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "storage_name": "getLiveSSTableCount", "type": "jmx"}, "cf-sstables-per-read": {"aggregation_type": "histogram", "allow_alerts": true, "api_key": "cf-sstables-per-read", "is_table_metric": true, "description": "The min, median, max, 90th, and 99th percentile of how many SSTables are accessed during a read.", "group": "cf", "histogram": true, "label": "TBL: SSTables per Read (percentiles)", "max": "<b>Max</b> - Maximum number of SSTables accessed during this period for a single read on this table.", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=SSTablesPerReadHistogram", "median": "<b>Median</b> - 50 percent of reads accessed no more than this many SSTables during the period.", "metric_type": "histogram", "min": "<b>Min</b> - Minimum number of SSTables accessed during this period for a single read on this table.", "p90th": "<b>90th</b> - 90 percent of reads accessed no more than this many SSTables during the period.", "p99th": "<b>99th</b> - 99 percent of reads accessed no more than this many SSTables during the period.", "invoke": ["values"], "plot": "Areas", "scope": "cf", "type": "jmx", "unit": "sstables"}, "cf-partition-size": {"aggregation_type": "histogram", "allow_alerts": true, "api_key": "cf-partition-size", "is_table_metric": true, "description": "The min, median, max, 90th, and 99th percentile of the size (in bytes) of partitions of this table.", "group": "cf", "histogram": true, "label": "TBL: Partition Size (percentiles)", "label_func": "logLabel", "max": "<b>Max</b> - Maximum size of a partition in bytes.", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=EstimatedPartitionSizeHistogram", "path": ["Value"], "median": "<b>Median</b> - 50 percent of partitions are no larger than this.", "metric_type": "histogram-gauge", "min": "<b>Min</b> - Minimum size of a partition in bytes", "p90th": "<b>90th</b> - 90 percent of partitions are no larger than this.", "p99th": "<b>99th</b> - 99 percent of partitions are no larger than this.", "plot": "Areas", "scale": "logScale", "scope": "cf", "type": "jmx", "render_type": "var-filesize", "unit": ""}, "cf-column-count": {"aggregation_type": "histogram", "allow_alerts": true, "api_key": "cf-column-count", "is_table_metric": true, "description": "The min, median, max, 90th, and 99th percentile of how many cells exist in partitions for this table.", "group": "cf", "histogram": true, "label": "TBL: Cell Count (percentiles)", "max": "<b>Max</b> - Maximum number of cells in a partition.", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=EstimatedColumnCountHistogram", "median": "<b>Median</b> - 50 percent of partitions have no more than this many cells.", "metric_type": "histogram-gauge", "min": "<b>Min</b> - Minimum number of cells in a partition.", "p90th": "<b>90th</b> - 90 percent of partitions have no more than this many cells.", "p99th": "<b>99th</b> - 99 percent of partitions have no more than this many cells.", "path": ["Value"], "plot": "Areas", "scope": "cf", "type": "jmx", "unit": "cells"}, "cf-bf-space-used": {"aggregation_type": "average", "alerts_label": "Bloom Filter Space Used", "api_key": "cf-bf-space-used", "is_table_metric": true, "description": "The total size of all the SSTables' bloom filters for this table.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Bloom Filter Space Used", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=BloomFilterDiskSpaceUsed", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "storage_name": "getBloomFilterSpaceUsed", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-bf-false-positives": {"aggregation_type": "average", "alerts_label": "Bloom Filter False Positives", "api_key": "cf-bf-false-positives", "is_table_metric": true, "description": "Number of bloom filter false positives per second.", "group": "cf", "label": "TBL: Bloom Filter False Positives", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=BloomFilterFalsePositives", "metric_type": "derive", "path": ["Value"], "scope": "cf", "storage_name": "getBloomFilterFalsePositives", "type": "jmx", "unit": "/sec"}, "cf-bf-false-ratio": {"aggregation_type": "average", "alerts_label": "Bloom Filter False Positive Ratio", "api_key": "cf-bf-false-ratio", "is_table_metric": true, "description": "Percentage of bloom filter lookups that resulted in a false positive.", "group": "cf", "hardmax": 1, "label": "TBL: Bloom Filter False Positive Ratio", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=RecentBloomFilterFalseRatio", "metric_type": "gauge", "minstep": 0.0005, "path": ["Value"], "precision": 4, "scope": "cf", "storage_name": "getRecentBloomFilterFalseRatio", "type": "jmx"}, "solr-requests": {"aggregation_type": "counter", "alerts_label": "Search Requests", "api_key": "solr-requests", "is_table_metric": true, "description": "Requests per second made to a specific Solr core/index.", "group": "solr", "label": "Search: Requests", "mbean": "solr/{keyspace}.{table}:type=search,id=org.apache.solr.handler.component.SearchHandler", "metric_type": "derive", "path": ["requests"], "postprocess": ["ensure-int"], "scope": "solr", "storage_name": "getSolrRequests", "type": "jmx", "unit": "/sec"}, "solr-avg-time-per-req": {"aggregation_type": "average", "alerts_label": "Search Request Latency", "api_key": "solr-avg-time-per-req", "is_table_metric": true, "description": "Average time a search query takes in a DSE cluster using DSE Search.", "group": "solr", "label": "Search: Request Latency", "mbean": "solr/{keyspace}.{table}:type=search,id=org.apache.solr.handler.component.SearchHandler", "metric_type": "gauge", "path": ["avgTimePerRequest"], "postprocess": ["ensure-float"], "scope": "solr", "storage_name": "getSolrAvgTimePerReq", "type": "jmx", "unit": "ms/request"}, "solr-errors": {"aggregation_type": "counter", "alerts_label": "Search Errors", "api_key": "solr-errors", "is_table_metric": true, "description": "Errors per second that occur for a specific Solr core/index.", "group": "solr", "label": "Search: Errors", "mbean": "solr/{keyspace}.{table}:type=search,id=org.apache.solr.handler.component.SearchHandler", "metric_type": "derive", "path": ["errors"], "postprocess": ["ensure-int"], "scope": "solr", "storage_name": "getSolrErrors", "type": "jmx", "unit": "/sec"}, "solr-timeouts": {"aggregation_type": "counter", "alerts_label": "Search Timeouts", "api_key": "solr-timeouts", "is_table_metric": true, "description": "Timeouts per second on a specific Solr core/index.", "group": "solr", "label": "Search: Timeouts", "mbean": "solr/{keyspace}.{table}:type=search,id=org.apache.solr.handler.component.SearchHandler", "metric_type": "derive", "path": ["timeouts"], "postprocess": ["ensure-int"], "scope": "solr", "storage_name": "getSolrTimeouts", "type": "jmx", "unit": "/sec"}, "solr-index-size": {"aggregation_type": "counter", "allow_alerts": "true", "api_key": "solr-index-size", "is_table_metric": true, "description": "Size of the Solr core on disk.", "group": "solr", "label": "Search: Core Size", "mbean": "solr/{keyspace}.{table}:type=core,id={keyspace}.{table}", "metric_type": "gauge", "path": ["indexSizeInBytes"], "postprocess": ["solr-index-size"], "scope": "solr", "type": "jmx", "unit": "KB"}, "os-memory": {"api_key": "os-memory", "description": "Stacked graph of used, cached, and free memory.", "group": "os", "label": "OS: Memory (stacked)", "metrics": ["os-memory-cached", "os-memory-used", "os-memory-buffers", "os-memory-shared", "os-memory-free"], "os": "linux", "plot": "StackedAreas", "unit": "MB"}, "os-memory-osx": {"api_key": "os-memory-osx", "description": "Stacked graph of used and free memory.", "group": "os", "label": "OS: Memory (stacked)", "metrics": ["os-memory-used", "os-memory-free"], "os": "osx", "plot": "StackedAreas", "unit": "MB"}, "os-memory-free": {"aggregation_type": "average", "alerts_label": "Memory Free", "allow_alerts": true, "api_key": "os-memory-free", "description": "Total system memory currently free.", "group": "os", "label": "OS: Memory Free", "metric_type": "gauge", "os": ["linux", "osx"], "path": "free", "scope": "memory", "storage_name": "getMemFreeMb", "subtype": ["linux", "osx"], "type": "system", "unit": "MB"}, "os-memory-used": {"aggregation_type": "average", "alerts_label": "Memory Used", "allow_alerts": true, "api_key": "os-memory-used", "description": "Total system memory currently used.", "group": "os", "label": "OS: Memory Used", "metric_type": "gauge", "os": ["linux", "osx"], "path": "used", "scope": "memory", "storage_name": "getMemUsedMb", "subtype": ["linux", "osx"], "type": "system", "unit": "MB"}, "os-memory-shared": {"aggregation_type": "average", "alerts_label": "Memory Shared", "allow_alerts": true, "api_key": "os-memory-shared", "description": "Total amount of memory in shared memory space.", "group": "os", "label": "OS: Memory Shared", "metric_type": "gauge", "os": "linux", "path": "shared", "scope": "memory", "storage_name": "getMemSharedMb", "subtype": ["linux"], "type": "system", "unit": "MB"}, "os-memory-buffers": {"aggregation_type": "average", "alerts_label": "Memory Buffered", "allow_alerts": true, "api_key": "os-memory-buffers", "description": "Total system memory currently buffered.", "group": "os", "label": "OS: Memory Buffered", "metric_type": "gauge", "os": "linux", "path": "buffers", "scope": "memory", "storage_name": "getMemBuffersMb", "subtype": ["linux"], "type": "system", "unit": "MB"}, "os-memory-cached": {"aggregation_type": "average", "alerts_label": "Memory Cached", "allow_alerts": true, "api_key": "os-memory-cached", "description": "Total system memory currently cached.", "group": "os", "label": "OS: Memory Cached", "metric_type": "gauge", "os": "linux", "path": "cached", "scope": "memory", "storage_name": "getMemCachedMb", "subtype": ["linux"], "type": "system", "unit": "MB"}, "os-memory-win": {"api_key": "os-memory-win", "description": "Stacked graph of committed, cached, paged, non-paged, and free memory.", "group": "os", "label": "OS: Memory (stacked)", "metrics": ["os-memory-committed", "os-memory-sys-cache-resident", "os-memory-pool-paged", "os-memory-pool-nonpaged", "os-memory-avail"], "os": "windows", "plot": "StackedAreas", "unit": "MB"}, "os-memory-avail": {"aggregation_type": "average", "alerts_label": "Available Memory", "allow_alerts": true, "api_key": "os-memory-avail", "description": "Available physical memory.", "group": "os", "label": "OS: Memory Available", "metric_type": "gauge", "os": "windows", "path": null, "scope": "memory", "storage_name": "getMemAvailableMb", "subtype": ["win32"], "type": "system", "unit": "MB"}, "os-memory-committed": {"aggregation_type": "average", "alerts_label": "Committed Memory", "allow_alerts": true, "api_key": "os-memory-committed", "description": "Memory in use by the operating system.", "group": "os", "label": "OS: Memory Committed", "metric_type": "gauge", "os": "windows", "path": null, "scope": "memory", "storage_name": "getMemCommittedMb", "subtype": ["win32"], "type": "system", "unit": "MB"}, "os-memory-pool-paged": {"aggregation_type": "average", "alerts_label": "Pool Paged Resident Memory", "allow_alerts": true, "api_key": "os-memory-pool-paged", "description": "Allocated pool-paged-resident memory.", "group": "os", "label": "OS: Pool Paged Resident Memory", "metric_type": "gauge", "os": "windows", "path": null, "scope": "memory", "storage_name": "getMemPoolPagedResidentMb", "subtype": ["win32"], "type": "system", "unit": "MB"}, "os-memory-pool-nonpaged": {"aggregation_type": "average", "alerts_label": "Pool Nonpaged Memory", "allow_alerts": true, "api_key": "os-memory-pool-nonpaged", "description": "Allocated pool-nonpaged memory.", "group": "os", "label": "OS: Pool Nonpaged Memory", "metric_type": "gauge", "os": "windows", "path": null, "scope": "memory", "storage_name": "getMemPoolNonpagedMb", "subtype": ["win32"], "type": "system", "unit": "MB"}, "os-memory-sys-cache-resident": {"aggregation_type": "average", "alerts_label": "System Cache Resident Memory", "allow_alerts": true, "api_key": "os-memory-sys-cache-resident", "description": "Memory used by the file cache.", "group": "os", "label": "OS: System Cache Resident Memory", "metric_type": "gauge", "os": "windows", "path": null, "scope": "memory", "storage_name": "getMemSystemCacheResidentMb", "subtype": ["win32"], "type": "system", "unit": "MB"}, "cpu": {"api_key": "cpu", "description": "Stacked graph of iowait, steal, nice, system, user, and idle CPU usage.", "group": "os", "label": "OS: CPU (stacked)", "metrics": ["os-cpu-steal", "os-cpu-iowait", "os-cpu-user", "os-cpu-nice", "os-cpu-idle", "os-cpu-system"], "os": "linux", "plot": "StackedAreas", "render_type": "percentage"}, "cpu-osx": {"api_key": "cpu-osx", "description": "Stacked graph of idle, user, and system CPU usage.", "group": "os", "label": "OS: CPU (stacked)", "metrics": ["os-cpu-idle", "os-cpu-user", "os-cpu-system"], "os": "osx", "plot": "StackedAreas", "render_type": "percentage"}, "cpu-win": {"api_key": "cpu-win", "description": "Stacked graph of user, privileged, and idle CPU usage.", "group": "os", "label": "OS: CPU (stacked)", "metrics": ["os-cpu-user", "os-cpu-privileged", "os-cpu-idle"], "os": "windows", "plot": "StackedAreas", "render_type": "percentage"}, "os-cpu-user": {"aggregation_type": "average", "alerts_label": "CPU: User", "api_key": "os-cpu-user", "description": "Time the CPU devotes to user processes.", "group": "os", "label": "OS: CPU User", "metric_type": "gauge", "path": null, "scope": "cpu", "storage_name": "getCpuUser", "subtype": ["win32"], "type": "system", "render_type": "percentage"}, "os-cpu-system": {"aggregation_type": "average", "alerts_label": "CPU: System", "api_key": "os-cpu-system", "description": "Time the CPU devotes to system processes.", "group": "os", "label": "OS: CPU System", "metric_type": "gauge", "os": ["linux", "osx"], "path": "%system", "scope": "cpu", "storage_name": "getCpuSystem", "subtype": ["linux", "osx"], "type": "system", "render_type": "percentage"}, "os-cpu-idle": {"aggregation_type": "average", "allow_alerts": false, "api_key": "os-cpu-idle", "description": "Time the CPU is idle.", "group": "os", "label": "OS: CPU Idle", "metric_type": "gauge", "path": "%idle", "scope": "cpu", "storage_name": "getCpuIdle", "subtype": ["linux", "osx"], "type": "system", "render_type": "percentage"}, "os-cpu-iowait": {"aggregation_type": "average", "alerts_label": "CPU: Iowait", "api_key": "os-cpu-iowait", "description": "Time the CPU devotes to waiting for I/O to complete.", "group": "os", "label": "OS: CPU Iowait", "metric_type": "gauge", "os": "linux", "path": "%iowait", "scope": "cpu", "storage_name": "getCpuIowait", "subtype": ["linux"], "type": "system", "render_type": "percentage"}, "os-cpu-steal": {"aggregation_type": "average", "alerts_label": "CPU: Steal", "api_key": "os-cpu-steal", "description": "Time the CPU devotes to tasks stolen by virtual operating systems.", "group": "os", "label": "OS: CPU Steal", "metric_type": "gauge", "os": "linux", "path": "%steal", "scope": "cpu", "storage_name": "getCpuSteal", "subtype": ["linux"], "type": "system", "render_type": "percentage"}, "os-cpu-nice": {"aggregation_type": "average", "alerts_label": "CPU: Nice", "api_key": "os-cpu-nice", "description": "Time the CPU devotes to processing nice tasks.", "group": "os", "label": "OS: CPU Nice", "metric_type": "gauge", "os": "linux", "path": "%nice", "scope": "cpu", "storage_name": "getCpuNice", "subtype": ["linux"], "type": "system", "render_type": "percentage"}, "os-cpu-privileged": {"aggregation_type": "average", "alerts_label": "CPU: Privileged", "api_key": "os-cpu-privileged", "description": "Time the CPU devotes to processing privileged instructions.", "group": "os", "label": "OS: CPU Privileged", "metric_type": "gauge", "os": "windows", "path": null, "scope": "cpu", "storage_name": "getCpuPrivileged", "subtype": ["win32"], "type": "system", "render_type": "percentage"}, "os-load": {"aggregation_type": "average", "alerts_label": "Load", "api_key": "os-load", "description": "Operating system load average.", "group": "os", "label": "OS: Load", "metric_type": "gauge", "minstep": 0.05, "path": "la", "precision": 2, "scope": "la", "storage_name": "getSystemLoad", "subtype": ["linux", "osx", "win32"], "type": "system"}, "os-disk-usage": {"aggregation_type": "os_disk_usage", "alerts_label": "Disk Usage (%)", "api_key": "os-disk-usage", "description": "Disk space used by Cassandra at a given time.", "group": "os", "has_items": true, "label": "OS: Disk Usage (%)", "metric_type": "gauge", "partition_specific": true, "path": "percentage", "scope": "disk", "storage_name": "getDiskUsagePercent", "subtype": ["linux", "osx", "win32"], "total": "<b>Total</b> - The sum of all the nodes disk used values divided by the sum of all the nodes total disk space.", "type": "system", "render_type": "percentage"}, "os-disk-free": {"aggregation_type": "counter", "alerts_label": "Free Disk Space (GB)", "api_key": "os-disk-free", "description": "Free space on a specific disk partition.", "group": "os", "has_items": true, "label": "OS: Disk Free", "metric_type": "gauge", "partition_specific": true, "path": "free", "precision": 2, "scope": "disk", "storage_name": "getDiskSpaceGbFree", "subtype": ["linux", "osx", "win32"], "type": "system", "unit": "GB"}, "os-disk-used": {"aggregation_type": "counter", "alerts_label": "Used Disk Space (GB)", "api_key": "os-disk-used", "description": "Disk space used by Cassandra at a given time.", "group": "os", "has_items": true, "label": "OS: Disk Used", "metric_type": "gauge", "partition_specific": true, "path": "used", "precision": 2, "scope": "disk", "storage_name": "getDiskSpaceGbUsed", "subtype": ["linux", "osx", "win32"], "type": "system", "unit": "GB"}, "os-disk-read-throughput": {"aggregation_type": "average", "alerts_label": "Disk Read Throughput", "api_key": "os-disk-read-throughput", "description": "Average disk throughput for read operations.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Read Throughput", "metric_type": "gauge", "os": ["linux", "windows"], "path": "Disk Read Bytes/sec", "postprocess": ["gb->mb"], "scope": "iostat", "storage_name": "getDiskMbsecRead", "subtype": ["win32"], "type": "system", "unit": "MB/sec"}, "os-disk-write-throughput": {"aggregation_type": "average", "alerts_label": "Disk Write Throughput", "api_key": "os-disk-write-throughput", "description": "Average disk throughput for write operations.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Write Throughput", "metric_type": "gauge", "os": ["linux", "windows"], "path": "Disk Write Bytes/sec", "postprocess": ["gb->mb"], "scope": "iostat", "storage_name": "getDiskMbsecWritten", "subtype": ["win32"], "type": "system", "unit": "MB/sec"}, "os-disk-throughput": {"aggregation_type": "average", "alerts_label": "Disk Throughput", "api_key": "os-disk-throughput", "description": "Average disk throughput for read and write operations.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Throughput", "metric_type": "gauge", "minstep": 0.1, "os": "osx", "path": "MB/s", "scope": "iostat", "storage_name": "getDiskMbsec", "subtype": ["osx"], "type": "system", "unit": "MB/sec"}, "os-disk-read-rate": {"aggregation_type": "average", "alerts_label": "Disk Read Rate", "api_key": "os-disk-read-rate", "description": "Rate of reads per second to the disk.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Read Rate", "metric_type": "gauge", "os": ["linux", "windows"], "path": "Disk Reads/sec", "scope": "iostat", "storage_name": "getDiskReadsSec", "subtype": ["win32"], "type": "system", "unit": "/sec"}, "os-disk-write-rate": {"aggregation_type": "average", "alerts_label": "Disk Write Rate", "api_key": "os-disk-write-rate", "description": "Rate of writes per second to the disk.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Writes Rate", "metric_type": "gauge", "os": ["linux", "windows"], "path": "Disk Writes/sec", "scope": "iostat", "storage_name": "getDiskWritesSec", "subtype": ["win32"], "type": "system", "unit": "/sec"}, "os-disk-await": {"aggregation_type": "average", "alerts_label": "Disk Latency", "api_key": "os-disk-await", "description": "Average completion time of each request to the disk.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Latency", "metric_type": "gauge", "os": ["linux", "windows"], "path": "Avg. Disk sec/Transfer", "postprocess": ["us->ms"], "scope": "iostat", "storage_name": "getDiskAwaitMillis", "subtype": ["win32"], "type": "system", "unit": "ms"}, "os-disk-request-size": {"aggregation_type": "average", "alerts_label": "Disk Request Size", "api_key": "os-disk-request-size", "description": "Average size of read requests issued to the disk.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Request Size", "metric_type": "gauge", "os": ["linux", "osx"], "path": "avgrq-sz", "scope": "iostat", "storage_name": "getDiskAvgRequestSize", "subtype": ["linux"], "type": "system", "unit": "sectors"}, "os-disk-request-size-kb": {"aggregation_type": "average", "alerts_label": "Disk Request Size", "api_key": "os-disk-request-size-kb", "description": "Average size of read requests issued to the disk.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Request Size", "metric_type": "gauge", "os": "windows", "path": "Avg. Disk Bytes/Transfer", "postprocess": ["mb->kb"], "scope": "iostat", "storage_name": "getDiskAvgRequestKb", "subtype": ["win32"], "type": "system", "unit": "KB"}, "os-disk-queue-size": {"aggregation_type": "average", "alerts_label": "Disk Queue Size", "api_key": "os-disk-queue-size", "description": "Average number of requests queued due to disk latency issues.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Queue Size", "metric_type": "gauge", "os": ["linux", "windows"], "path": "Avg. Disk Queue Length", "scope": "iostat", "storage_name": "getDiskAvgQueueSize", "subtype": ["win32"], "type": "system", "unit": "requests"}, "os-disk-utilization": {"aggregation_type": "average", "alerts_label": "Disk Utilization", "api_key": "os-disk-utilization", "description": "CPU time consumed by disk I/O.", "disk_specific": true, "group": "os", "has_items": true, "label": "OS: Disk Utilization", "metric_type": "gauge", "os": ["linux", "windows"], "path": "% Disk Time", "scope": "iostat", "storage_name": "getDiskUtilPercent", "subtype": ["win32"], "type": "system", "render_type": "percentage"}, "os-net-received": {"aggregation_type": "counter", "allow_alerts": false, "api_key": "os-net-received", "description": "Speed of data received from the network.", "group": "os", "has_items": true, "label": "OS: Net Received", "metric_type": "gauge", "path": "received", "scope": "network", "storage_name": "getNetKbReceived", "subtype": ["linux", "osx"], "to_unit": "perMin", "type": "system", "unit": "KB/sec"}, "os-net-sent": {"aggregation_type": "counter", "allow_alerts": false, "api_key": "os-net-sent", "description": "Speed of data sent across the network.", "group": "os", "has_items": true, "label": "OS: Net Sent", "metric_type": "gauge", "path": "sent", "scope": "network", "storage_name": "getNetKbSent", "subtype": ["linux", "osx"], "to_unit": "perMin", "type": "system", "unit": "KB/sec"}, "dashboard-read-write": {"label": "Cluster Reads & Writes", "metrics": [{"key": "write-ops", "label": "Writes"}, {"key": "read-ops", "label": "Reads"}], "selectable": false, "unit": "/sec", "api_key": "dashboard-read-write"}, "dashboard-latency": {"label": "Cluster Latency", "metrics": [{"key": "write-histogram", "label": "Writes"}, {"key": "read-histogram", "label": "Reads"}], "minstep": 0.1, "selectable": false, "unit": "ms/op", "api_key": "dashboard-latency"}, "cassandramemory": {"group": "cassandra", "label": "Cassandra JVM Memory Usage", "metrics": ["heap-used", "heap-max"], "selectable": false, "render_type": "filesize", "api_key": "cassandramemory"}, "cf-sstable-size": {"is_table_metric": true, "group": "cf", "label": "TBL: SSTable Size", "metrics": ["cf-live-disk-used", "cf-total-disk-used"], "selectable": false, "render_type": "filesize", "api_key": "cf-sstable-size"}, "os-disk-space": {"group": "os", "has_items": true, "label": "OS: Disk Usage (GB)", "metrics": ["os-disk-free", "os-disk-used"], "precision": 2, "selectable": false, "unit": "GB", "api_key": "os-disk-space"}, "os-disk-throughput-grouped": {"group": "os", "has_items": true, "label": "OS: Disk Throughput", "metrics": ["os-disk-write-throughput", "os-disk-read-throughput"], "minstep": 0.1, "os": ["linux", "windows"], "selectable": false, "unit": "MB/sec", "api_key": "os-disk-throughput-grouped"}, "os-disk-rate": {"alerts_label": "Disk Rates", "group": "os", "has_items": true, "label": "OS: Disk Rates", "metrics": ["os-disk-write-rate", "os-disk-read-rate"], "os": ["linux", "windows"], "selectable": false, "unit": "/sec", "api_key": "os-disk-rate"}, "os-net-traffic": {"group": "os", "has_items": true, "label": "OS: Network Traffic", "metrics": ["os-net-received", "os-net-sent"], "selectable": false, "to_unit": "perMin", "unit": "KB/sec", "api_key": "os-net-traffic"}, "os-net-sent-win": {"aggregation_type": "counter", "api_key": "os-net-sent-win", "description": "Speed of data sent across the network.", "group": "os", "label": "OS: Net Sent", "metric_type": "gauge", "path": null, "scope": "network", "storage_name": "getNetKbSecSent", "subtype": ["win32"], "selectable": false, "type": "system"}, "os-net-received-win": {"aggregation_type": "counter", "api_key": "os-net-received-win", "description": "Speed of data received from the network.", "group": "os", "label": "OS: Net Received", "metric_type": "gauge", "path": null, "scope": "network", "storage_name": "getNetKbSecReceived", "subtype": ["win32"], "selectable": false, "type": "system"}, "cf-bf-offheap": {"aggregation_type": "average", "alerts_label": "Bloom Filter Off Heap", "api_key": "cf-bf-offheap", "is_table_metric": true, "description": "Total off heap memory used by bloom filters from all live SSTables in a table.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Bloom Filter Off Heap", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=BloomFilterOffHeapMemoryUsed", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-index-summary-offheap": {"aggregation_type": "average", "alerts_label": "Index Summary Off Heap", "api_key": "cf-index-summary-offheap", "is_table_metric": true, "description": "Total off heap memory used by the index summary of all live SSTables in a table.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Index Summary Off Heap", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=IndexSummaryOffHeapMemoryUsed", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-compression-data-offheap": {"aggregation_type": "average", "alerts_label": "Compression Metadata Off Heap", "api_key": "cf-compression-data-offheap", "is_table_metric": true, "description": "Total off heap memory used by the compression metadata of all live SSTables in a table.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Compression Metadata Off Heap", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=CompressionMetadataOffHeapMemoryUsed", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "pending-counter-mutations": {"aggregation_type": "counter", "api_key": "pending-counter-mutations", "description": "Pending tasks to execute local counter mutations.", "group": "cassandra", "label": "TP: Counter Mutations Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=CounterMutationStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "active-counter-mutations": {"aggregation_type": "counter", "api_key": "active-counter-mutations", "description": "Up to concurrent_counter_writes running tasks that execute local counter mutations.", "group": "cassandra", "label": "TP: Counter Mutations Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=CounterMutationStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "completed-counter-mutations": {"aggregation_type": "counter", "api_key": "completed-counter-mutations", "description": "Number of local counter mutations that have been executed.", "group": "cassandra", "label": "TP: Counter Mutations Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=CounterMutationStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "memtable-reclaim-pending": {"aggregation_type": "counter", "api_key": "memtable-reclaim-pending", "description": "Waits for current reads to complete and then frees the memory formerly used by the obsoleted memtables.", "group": "cassandra", "label": "TP: Memtable Reclaims Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtableReclaimMemory,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "memtable-reclaim-active": {"aggregation_type": "counter", "api_key": "memtable-reclaim-active", "description": "Waits for current reads to complete and then frees the memory formerly used by the obsoleted memtables.", "group": "cassandra", "label": "TP: Memtable Reclaims Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtableReclaimMemory,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "completed-memtable-reclaim": {"aggregation_type": "counter", "api_key": "completed-memtable-reclaim", "description": "Waits for current reads to complete and then frees the memory formerly used by the obsoleted memtables.", "group": "cassandra", "label": "TP: Memtable Reclaims Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtableReclaimMemory,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "cf-memtable-offheap": {"aggregation_type": "average", "alerts_label": "Memtable Off Heap", "api_key": "cf-memtable-offheap", "is_table_metric": true, "description": "Off heap memory used by a table's current memtable.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Memtable Off Heap", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=MemtableOffHeapSize", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-all-memtables-heapsize": {"aggregation_type": "counter", "alerts_label": "Total Memtable Heap Size", "api_key": "cf-all-memtables-heapsize", "is_table_metric": true, "description": "An estimate of the space used in JVM heap memory for all memtables. This includes ones that are currently being flushed and related secondary indexes.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Total Memtable Heap Size", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=AllMemtablesHeapSize", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-all-memtables-livedatasize": {"aggregation_type": "counter", "alerts_label": "Total Memtable Live Data Size", "api_key": "cf-all-memtables-livedatasize", "is_table_metric": true, "description": "An estimate of the space used for 'live data' (off-heap, excluding overhead) for all memtables. This includes ones that are currently being flushed and related secondary indexes.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Total Memtable Live Data Size", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=AllMemtablesLiveDataSize", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-all-memtables-offheapsize": {"aggregation_type": "counter", "alerts_label": "Total Memtable Off-Heap Size", "api_key": "cf-all-memtables-offheapsize", "is_table_metric": true, "description": "An estimate of the space used in off-heap memory for all memtables. This includes ones that are currently being flushed and related secondary indexes.", "from_unit": "gbToBytes", "group": "cf", "label": "TBL: Total Memtable Off-Heap Size", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=AllMemtablesOffHeapSize", "metric_type": "gauge", "path": ["Value"], "scope": "cf", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "in-memory-percent-used": {"aggregation_type": "average", "allow_alerts": "true", "api_key": "in-memory-percent-used", "description": "The percentage of memory allocated for in-memory tables currently in use.", "group": "dse", "label": "In-Memory Percent Used", "mbean": "com.datastax.bdp:type=core,name=MemoryOnlyStatus", "metric_type": "gauge", "path": ["MemoryOnlyPercentUsed"], "postprocess": ["in-memory-percent-used"], "scope": "general", "render_type": "percentage", "type": "jmx"}, "cf-row-size": {"aggregation_type": "average", "api_key": "cf-row-size", "is_table_metric": true, "description": "Approximate number of partitions. This may be off given duplicates in memtables and sstables are both counted and there is a very small error percentage inherited from the HyperLogLog data structure.", "group": "cf", "label": "TBL: Partition Count", "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=EstimatedPartitionCount", "path": ["Value"], "metric_type": "gauge", "scope": "cf", "type": "jmx"}, "write-latency-legacy": {"aggregation_type": "histogram-avg", "allow_alerts": false, "api_key": "write-latency-legacy", "description": "<b>Deprecated</b>. The <i>median</i> response times (in milliseconds) of a client write. The time period starts when a node receives a client write request, and ends when the node responds back to the client. Depending on consistency level and replication factor, this may include the network latency from writing to the replicas.", "label": "Write Request Latency", "min": "<b>Min</b> - The minimum latency during a time interval.", "average": "<b>Avg</b> - The <i>median</i> of values a time interval.", "max": "<b>Max</b> - The maximum latency during a time interval.", "minstep": 0.1, "priority": 2, "wraps_histogram": "write-histogram", "to_unit": "nsToMs", "from_unit": "msToNs", "unit": "ms/op"}, "read-latency-legacy": {"aggregation_type": "histogram-avg", "allow_alerts": false, "api_key": "read-latency-legacy", "description": "<b>Deprecated</b>. The <i>median</i> response times (in milliseconds) of a client read. The time period starts when a node receives a client read request, and ends when the node responds back to the client. Depending on consistency level and replication factor, this may include the network latency from requesting the data's replicas.", "label": "Read Request Latency", "min": "<b>Min</b> - The minimum latency during a time interval.", "average": "<b>Avg</b> - The <i>median</i> of values a time interval.", "max": "<b>Max</b> - The maximum latency during a time interval.", "minstep": 0.1, "priority": 3, "wraps_histogram": "read-histogram", "to_unit": "nsToMs", "from_unit": "msToNs", "unit": "ms/op"}, "view-write-histogram": {"aggregation_type": "histogram", "allow_alerts": true, "api_key": "view-write-histogram", "description": "The min, median, max, 90th, and 99th percentiles of the time from when base mutation is applied to memtable until CL.ONE is achieved on the async write to the tables materialized views. An estimate to determine the lag between base table mutations and the views consistency.", "group": "cassandra", "histogram": true, "label": "View Write Latency (percentiles)", "label_func": "logLabel", "max": "<b>Max</b> - The maximum latency during a time interval.", "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=ViewWrite,name=ViewWriteLatency", "invoke": ["values"], "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.", "metric_type": "histogram", "min": "<b>Min</b> - The minimum latency during a time interval.", "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.", "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.", "plot": "Areas", "priority": 5, "scale": "logScale", "scope": "general", "type": "jmx", "unit": "ms/op"}, "view-replicas-success": {"aggregation_type": "counter", "api_key": "view-replicas-success", "description": "Number of view mutations sent to replicas that have been acknowledged.", "group": "cassandra", "label": "View Write Successes", "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=ViewWrite,name=ViewReplicasSuccess", "path": ["Count"], "metric_type": "gauge", "priority": 6, "scope": "general", "type": "jmx", "unit": "mutations"}, "view-replicas-pending": {"aggregation_type": "counter", "api_key": "view-replicas-pending", "description": "Number of view mutations sent to replicas where the replicas acknowledgement hasn't been received.", "group": "cassandra", "label": "View Write Pending", "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=ViewWrite,name=ViewPendingMutations", "path": ["Value"], "metric_type": "gauge", "priority": 6, "scope": "general", "type": "jmx", "unit": "mutations"}, "pending-view-mutation-stage": {"aggregation_type": "counter", "api_key": "pending-view-mutation-stage", "description": "Number of mutations to apply locally after modifications to a base table.", "group": "cassandra", "label": "TP: View Mutations Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ViewMutationStage,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "active-view-mutation-stage": {"aggregation_type": "counter", "api_key": "active-view-mutation-stage", "description": "Number of mutations to being applied locally after modifications to a base table.", "group": "cassandra", "label": "TP: View Mutations Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ViewMutationStage,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "completed-view-mutation-stage": {"aggregation_type": "counter", "api_key": "completed-view-mutation-stage", "description": "Number of mutations applied locally after modifications to a base table.", "group": "cassandra", "label": "TP: View Mutations Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ViewMutationStage,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "pending-hint-dispatcher": {"aggregation_type": "counter", "api_key": "pending-hint-dispatcher", "description": "Pending tasks to send the stored hinted handoffs to a host.", "group": "cassandra", "label": "TP: Hint Dispatcher Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=HintsDispatcher,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "active-hint-dispatcher": {"aggregation_type": "counter", "api_key": "active-hint-dispatcher", "description": "Up to max_hints_delivery_threads tasks, each dispatching all hinted handoffs to a host.", "group": "cassandra", "label": "TP: Hint Dispatcher Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=HintsDispatcher,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "completed-hint-dispatcher": {"aggregation_type": "counter", "api_key": "completed-hint-dispatcher", "description": "Number of tasks to transfer hints to a host that have completed.", "group": "cassandra", "label": "TP: Hint Dispatcher Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=HintsDispatcher,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "pending-secondary-index-management": {"aggregation_type": "counter", "api_key": "pending-secondary-index-management", "description": "Any initialization work when a new index instance is created. This may involve costly operations such as (re)building the index.", "group": "cassandra", "label": "TP: Index Management Pending", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=SecondaryIndexManagement,name=PendingTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "active-secondary-index-management": {"aggregation_type": "counter", "api_key": "active-secondary-index-management", "description": "Any initialization work when a new index instance is created. This may involve costly operations such as (re)building the index.", "group": "cassandra", "label": "TP: Index Management Active", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=SecondaryIndexManagement,name=ActiveTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "completed-secondary-index-management": {"aggregation_type": "counter", "api_key": "completed-secondary-index-management", "description": "Any initialization work when a new index instance is created. This may involve costly operations such as (re)building the index.", "group": "cassandra", "label": "TP: Index Management Completed", "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=SecondaryIndexManagement,name=CompletedTasks", "metric_type": "gauge", "path": ["Value"], "priority": 30, "scope": "general", "type": "jmx"}, "cf-write-latency-legacy": {"aggregation_type": "histogram-avg", "allow_alerts": false, "api_key": "cf-write-latency-legacy", "is_table_metric": true, "description": "<b>Deprecated</b>. Median response time to write data to a table's memtable. The elapsed time from when the replica receives the request from a coordinator and returns a response.", "group": "cf", "label": "TBL: Local Write Latency", "min": "<b>Min</b> - The minimum latency during a time interval.", "average": "<b>Avg</b> - The <i>median</i> of values a time interval.", "max": "<b>Max</b> - The maximum latency during a time interval.", "minstep": 0.1, "scope": "cf", "wraps_histogram": "cf-local-write-latency", "to_unit": "nsToMs", "from_unit": "msToNs", "unit": "ms/op"}, "cf-read-latency-legacy": {"aggregation_type": "histogram-avg", "allow_alerts": false, "api_key": "cf-read-latency-legacy", "is_table_metric": true, "description": "<b>Deprecated</b>. Median response time to read data from the memtable and SSTables for a specific table. The elapsed time from when the replica receives the request from a coordinator and returns a response.", "group": "cf", "label": "TBL: Local Read Latency", "min": "<b>Min</b> - The minimum latency during a time interval.", "average": "<b>Avg</b> - The <i>median</i> of values a time interval.", "max": "<b>Max</b> - The maximum latency during a time interval.", "minstep": 0.1, "scope": "cf", "wraps_histogram": "cf-local-read-latency", "to_unit": "nsToMs", "from_unit": "msToNs", "unit": "ms/op"}, "cf-tier-size": {"aggregation_type": "counter", "api_key": "cf-tier-size", "is_table_metric": true, "is_tier_metric": true, "description": "Disk space used by a table by SSTables for the tier.", "group": "tier", "label": "TIER: Total Disk Used", "metric_type": "gauge", "path": ["size"], "scope": "tier", "from_unit": "gbToBytes", "to_unit": "bytesToGb", "type": "jmx", "render_type": "filesize"}, "cf-tier-sstables": {"aggregation_type": "counter", "api_key": "cf-tier-sstables", "is_table_metric": true, "is_tier_metric": true, "description": "Number of SSTables in a tier for a table.", "group": "tier", "label": "TIER: sstables", "path": ["sstables"], "metric_type": "gauge", "scope": "tier", "type": "jmx", "unit": "sstables"}, "cf-tier-max-data-age": {"aggregation_type": "average", "allow_alerts": false, "api_key": "cf-tier-max-data-age", "is_table_metric": true, "is_tier_metric": true, "description": "Timestamp in local server time that represents an upper bound to the newest piece of data stored in the SSTable. When a new SSTable is flushed, it is set to the time of creation. When an SSTable is created from compaction, it is set to the max of all merged SSTables.", "group": "tier", "label": "TIER: Max Data Age", "path": ["max_data_age"], "metric_type": "gauge", "scope": "tier", "to_unit": "ageDuration", "render_type": "duration", "type": "jmx"}}